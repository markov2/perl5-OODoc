#!/usr/bin/env perl

use warnings;
use strict;

use Log::Report   'oodoc';

use Cwd               qw/getcwd realpath/;
use File::Copy        qw/move copy/;
use File::Glob        qw/bsd_glob/;
use File::Slurper     qw/read_text read_binary read_lines/;
use File::Spec::Functions qw/catfile rel2abs/;
use File::Basename    qw/basename dirname/;
use Getopt::Long      qw/GetOptions :config gnu_getopt/;
use HTML::Entities    qw/encode_entities/;
use JSON              ();
use List::Util        qw/first/;
use POSIX             qw/strftime/;

use OODoc             ();
use OODoc::Parser     ();

###
### Some constants
###

my $tmpdir      = $ENV{TMPDIR} || '/tmp';

my $default_pmhead = <<'__PMHEAD';
Copyrights $year$author.$contrib
See the manual pages for details on the licensing terms.
Pod stripped from pm file by OODoc $ooversion.
__PMHEAD

my $default_podtail = <<'__PODTAIL';
=head1 SEE ALSO

This module is part of $project distribution version $version,
built on $today.$web

=head1 LICENSE

Copyrights $year$author.$contrib
$lictext
__PODTAIL


sub extract_manuals($$);
sub extract_distro($;$);
sub create_pod($$$);
sub create_html($$);
sub oodist_meta($);
sub project_meta();
sub create_heads_and_tails($;$);
sub create_readme($$$);
sub create_meta($);
sub prepare_release($);
sub run_tests($);
sub publish_release($);
sub publish_raw_dist($);
sub create_html_dist($);
sub create_export($$);
sub read_makefile($);
sub read_meta($);
sub prepare_license($$);
sub string_expand_values($$$);

sub convert2version3();
sub config3();
sub merge3();

###
### Command-line parsing
###

Getopt::Long::Configure 'bundling';

GetOptions
	'all!'          => \(my $make_all),
	'exports!'      => \(my $make_exports),
	'release!'      => \(my $make_release),
	'export=s'      => \(my $make_export),
	'html!'         => \(my $make_html),
	'pod!'          => \(my $make_pod),
	'raw!'          => \(my $make_raw),
	'readme=s'      => \(my $readmefn),
	'tests|t!'      => \(my $run_tests),
	'verbose|v!'    => \(my $verbose = 0),
	'workdir|w=s'   => \(my $distdir),

	'config3'       => \(my $config3),
	'merge3'        => \(my $merge3),
	or error __"stopped";

! @ARGV
	or error __x"No command-line arguments expected.";

my $any_requested = $make_release || $make_exports || $make_export || $make_html || $make_pod || $make_raw || $run_tests;
if($make_all || ! $any_requested)
{	# explicit all, but not -no-*
	$_ //= 1 for $make_release, $make_export, $make_html, $make_pod, $make_raw, $run_tests;
}

dispatcher mode => $verbose, 'ALL';

my $ooversion = $OODoc::VERSION || 'devel';

###
### collect some project info
###

system "perl Makefile.PL"
	and fault "cannot run Makefile.PL for basic information";

my $makefile  = read_makefile 'Makefile';
my $meta      = read_meta 'MYMETA.json';

my $config    = $meta->{x_oodoc} || $meta->{oodoc};

### Help people convert from OODoc2 to OODoc3
if($config3)  { config3; exit 0 }
if($merge3)   { merge3; exit 0 }
if(! $config) { convert2version3; exit 1 }

my $author    = $meta->{author} =~ s/\s+\<(.*?)\>//r;
my $email     = $meta->{email}   || $1;

my $project   = $meta->{name};
my $version   = $meta->{version};
my $distvname = "$project-$version";

$distdir ||= "$tmpdir/$project";
-d $distdir || mkdir $distdir
	or fault __x"Cannot create workdir at {dir}", dir => $distdir;

info "*** Producing $project version $version";

###
### Start OODoc
###

my $doc  = OODoc->new
  ( distribution => $project
  , version      => $version  # version of whole
  );

# Reading all the manual pages
my $source  = realpath '.';
my %distros = ($project => $meta);
extract_manuals $source, $distdir;  # produces $distdir

info "** Merge the manuals into one documentation set";
$doc->prepare;

# Generate various products
foreach my $gen (@{$meta->{generate} || []})
{
	if(my $format = $gen->{format})
	{	if($format =~ /^pod/)
		{	create_pod $doc, $gen, $distdir if $make_pod;
		}
		elsif($format =~ /^html/)
		{	create_html $doc, $gen if $make_html;
		}
		else
		{	error __x"unknown format '{format}' to generate.", format => $format;
		}
	}
	elsif(my $export = $gen->{export})
	{	if($make_exports && (!$make_export || $export eq $make_export))
		{	create_export $doc, $gen;
		}
	}
	else
	{	error __x"unknown generation type in configuration.";
	}
}

# Produce release

if($run_tests || $make_release || $make_raw)
{
	prepare_release $distdir;

	run_tests $distdir
		if $run_tests;

	publish_release $distdir
		if $make_release;

	publish_raw_dist $distdir
		if $make_raw;
}

info "* Ready";
exit 0;

sub extract_manuals($$)
{	my ($indir, $outdir) = @_;

	print "** Extracting manuals from the distributions";
	extract_distro $source, $outdir;
}

my %included_dirs;

sub extract_distro($;$)
{	my ($dir, $outdir) = @_;
	return if $included_dirs{$dir};

	my $lib     = "$dir/lib";
	push @INC, $lib unless grep $_ eq $lib, @INC;

	foreach my $include (@{$config->{includes} || []})
	{	my $absdir = realpath (rel2abs $include, $dir);
		extract_distro $absdir;
	}

	# Do not run Makefile.PL because the included distry may be in broken state.

	my $is_root   = defined $outdir;
	my $dist_meta = $is_root ? $meta : read_meta "$dir/MYMETA.json";
	my $dist_name = $dist_meta->{name};
	my $version   = $dist_meta->{version};

	$distros{$dist_name} = $dist_meta;
	$included_dirs{$dir} = $dist_name;

	my $dist_config = $dist_meta->{x_oodoc} || $dist_meta->{oodoc};
	unless($dist_config)
	{	warning __x"distribution {name} is not yet converted to OODoc v3, hence ignored.", name => $dist_name;
		return;
	}

	info "* processing files of $dist_name $version in $dir";

	# Every distribution may have different parser rules.
	my $p_config = $dist_config->{parser} || { };
	my $pmheadfn = rel2abs delete $p_config->{pmhead} || 'PMHEAD.txt', $dir;
	my $parser   = OODoc::Parser->new(%$p_config);

	if($is_root)
	{	my $pmhead   = -f $pmheadfn ? read_text $pmheadfn : $default_pmhead;

		$doc->processFiles(
			workdir    => $outdir,
			version    => $version,
			parser     => $parser,
			notice     => string_expand_values($pmhead, $dir, $dist_meta),
		);

		create_readme $doc, $readmefn, $outdir
			if $readmefn && ! -f $readmefn;
	}
	else
	{	$doc->processFiles(
			parser     => $parser,
			select     => qr[^ lib/ .*? \.(?:pod|pm) $ ]x
		);
	}
}

#
# Create pods
# Only for the manuals in the source distribution.
#

sub create_pod($$$)
{	my ($doc, $gen, $outdir) = @_;

	my $format = $gen->{format};
	info "** Creating POD files with $format";

	my $podtailfn = rel2abs +($gen->{podtail} || 'PODTAIL.txt'), $source;
	my $podtail   = -f $podtailfn ? read_text $podtailfn : $default_podtail;

	$doc->formatter($format,
		workdir => $outdir,
	)->createPages(
	    select  => sub { my $manual = shift; $manual->distribution eq $project },
	    append  => string_expand_values($podtail, $source, $meta),
	);

	# The POD output is not published separately, but as part of the release.
}

#
# Create html
#

sub create_html($$)
{	my ($doc, $gen) = @_;

	my $format    = $gen->{format};
	my $webpages  = $gen->{webpages}
		or error __x"html generation needs a location for the webpages.";

	info "* Creating HTML with $format, files in $webpages";

	chdir $source or panic;

	my $templates = $gen->{templates} // 'html';

	$doc->formatter($format,
		workdir         => $webpages,
	 	html_root       => $gen->{docroot}    // '/',
		html_stylesheet => $gen->{stylesheet},
	)->createPages(
		manual_format    => [],
		manual_templates => "$templates/manual",
		other_templates  => "$templates/other",
	);

	# Only continue when the combined HTML is to be packaged.
	my $dest     = $gen->{publish} or return;
	-d $dest || mkdir $dest
		or fault __x"cannot create {dir}", dir => $dest;

	my $htmlfile = "$distvname-html.tar.gz";

	info "*  building html package $htmlfile";
	unlink $htmlfile;

	local $" = ' ';
	system "tar czf $htmlfile *"
		and fault __x"cannot produce {file} with tar", file => $htmlfile;

	return if $dest eq $source;

	info "*  publish HTML package to $dest/$htmlfile";

	move $htmlfile, $dest
		or fault __x"cannot move {from} to {to}", from => $htmlfile, to=>$dest;
}

#
# string_expand_values($$$)
# The pmhead and podtail are flexible texts, which can have some values filled-in.
# These names are have not changed in v3, but more information is provided.

sub string_expand_values($$$)
{	my ($string, $dir, $dist_meta) = @_;
	my $config  = $dist_meta->{x_oodoc} || $dist_meta->{oodoc};

	my $year    = strftime "%Y", localtime;
	if(my $firstyear = $config->{first_year})
	{	$year = $firstyear =~ m/$year$/ ? $firstyear
		      : $firstyear =~ m/\D$/    ? $firstyear.$year
		      : "$firstyear-$year";
	}

	my $website = $dist_meta->{resources}{homepage};
	my $author  = $dist_meta->{author};
	my $email   = $author =~ s/ \<(.*?)\>// ? $1 : undef;
	$email      = $config->{email} if exists $config->{email};

	my $log     = first { m/^(?:change|contrib)/i } bsd_glob '*';
	my $contrib = $log ? <<__CONTRIB =~ s/\n//r : '';
 For other contributors see $log.
__CONTRIB

	my %vars = (
		today     => (strftime "%B %d, %Y", localtime),
		year      => $year,     # license year range, backwards compatible name
	 	web       => $website ? " Website: F<$website>" : '',
		website   => $website,
		ooversion => $ooversion,
		author    => $author ? "by $author" : '',
		email     => $email || '',
		project   => $dist_meta->{name},
		version   => $dist_meta->{version},
	    lictext   => (prepare_license $dir, $dist_meta),
	    changelog => $log,
		contrib   => $contrib,
	);

	$string =~ s/(?: \$(\w+) | \$\{(\w+)\} )/
		my $key = $+;
	    exists $vars{$key} or error __x"unknown pmhead or podtail field '{name}'.", name => $key;
	    $vars{$key};
	 /grxe;
}

#
# License text
#

my %licenses = (
	artistic => <<__ARTISTIC,
This program is free software; you can redistribute it and/or modify it
under the Artistic license.
See F<http://dev.perl.org/licenses/artistic.html>
__ARTISTIC
	as_perl => <<__PERL,
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See F<http://dev.perl.org/licenses/>
__PERL
	gpl => <<__GPL
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
for more details: F<http://www.gnu.org/licenses/gpl.html>
__GPL
);
$licenses{perl}   = $licenses{as_perl};
$licenses{perl_5} = $licenses{as_perl};

sub prepare_license($$)
{	my ($proj_dir, $proj_meta) = @_;
	my $license = ($proj_meta->{licenses} || [ 'perl_5' ])->[0];
	my $lictext = $licenses{$license} || '';

	if(!$lictext && $license)
	{	my $fn = rel2abs $license, $proj_dir;
		$lictext = read_text $fn
			or fault __x"cannot read licence from file {file}", file => $fn;
	}

	$lictext;
}

#
# create_readme()
# When the README file is missing, something useful gets added.

sub create_readme($$$)
{	my ($doc, $readmefn, $workdir) = @_;
	my @toplevel = bsd_glob "$distdir/*";

	my $readme   = first { /\breadme$/i } @toplevel;
	return 1 if $readme;

	info "* adding README";

	my $manifest = first { /\bmanifest$/i } @toplevel;
	open MANIFEST, '>>', $manifest
		or fault __x"cannot append to {file}", file => $manifest;
	print MANIFEST "README\n";
	close MANIFEST;

	$readme      = catfile $distdir, 'README';

	if($readmefn)
	{	# user provided README
		info "* copying $readmefn as README\n";

		copy $readmefn, $readme
			or fault __x"cannot copy {from} to {to}", from => $readmefn, to => $readme;

		return 1;
	}

	# Produce a README text

	open README, '>:encoding(utf8)', $readme
		or fault __x"cannot write to {file}", file => $readme;

	my $date = localtime;

	print README <<__README;
=== README for $project version $version
=   Generated on $date by OODoc $ooversion

There are various ways to install this module:

 (1) if you have a command-line, you can do:
	   perl -MCPAN -e 'install <any package from this distribution>'

 (2) if you use Windows, have a look at http://ppm.activestate.com/

 (3) if you have downloaded this module manually (as root/administrator)
	   gzip -d $project-$version.tar.gz
	   tar -xf $project-$version.tar
	   cd $project-$version
	   perl Makefile.PL
	   make          # optional
	   make test     # optional
	   make install

For usage, see the included manual-pages or
	http://search.cpan.org/dist/$project-$version/

Please report problems to
	http://rt.cpan.org/Dist/Display.html?Queue=$project

__README

	close README;
	1;
}

# Since ExtUtils::MakeMaker, the META files only get updated when
# they already exist.
sub create_meta($)
{	my ($doc) = @_;
	my $manifest = first { /\bmanifest$/i } bsd_glob "*";
	$manifest or panic "No manifest";

	foreach my $fn ('META.yml', 'META.json')
	{	next if -f $fn;
		info "adding $fn";
		open META, '>>', $fn and close META;

		open MANIFEST, '>>', $manifest
			or fault __x"cannot append to {file}", file => $manifest;

		print MANIFEST "$fn\n";
		close MANIFEST;
	}
}

#
# Run tests
#

sub run_tests($)
{	my ($distdir) = @_;
 	info "** Running tests";

	my $tests = $config->{tests} || {};

	chdir $distdir
		or fault __x"cannot chdir to run tests in {dir}", dir => $distdir;

	foreach my $testdir (qw/t tests xt/)
	{	-d $testdir or next;

		info "* Running tests in $testdir";
		system "make test TEST_FILES=$testdir/*.t"
#           and fault __x"make test in {dir} failed", dir => $testdir;
	}
}

#
# Create a distribution
#

sub prepare_release($)
{	my ($distdir) = @_;

	info "** Creating the release for $distvname";

	info "*  prepare release in $distdir";

	chdir $distdir
		or fault __x"cannot chdir to prepare release in {dir}", dir => $distdir;

	system "perl Makefile.PL"
		and fault __x"perl Makefile.PL failed";

	system "make clean >/dev/null"
		and fault __x"make clean failed";

	move 'Makefile.old', 'Makefile'
		or fault __x"cannot reinstate Makefile";

	system "make distdir" # >/dev/null"
	   and fault __x"make distdir failed";
}

sub publish_release($)
{	my ($distdir) = @_;

 	info "** Publish release";

	my $release = $config->{release}
		or (info "release output not configured."), return;

	chdir $distdir
		or fault __x"cannot chdir to publish release in {dir}", dir => $distdir;

	my $dest = rel2abs +($release->{publish} // '.'), $source;
	-d $dest || mkdir $dest
		or fault __x"cannot create release directory {dir}", dir => $dest;

	my $distfile = "$distvname.tar.gz";

	info "*  building distribution in $distfile";
	unlink $distfile;

	system "make dist >/dev/null"
		and fault __x"make dist in {dir} failed", dir => $distdir;

	return if $dest eq $distdir;

	info "*  publish release in $dest";

	-f $distfile
		or error __x"cannot find produced {file}", file => $distfile;

	-d $dest or mkdir $dest
		or fault __x"cannot create {dir}", dir => $dest;

	move $distfile, $dest
		or fault __x"cannot move {from} to {to}", from => $distfile, to=>$dest;
}

#
# Create RAW
#

sub create_raw($)
{	my ($distdir) = @_;

	info "** Create package with raw distribution";

	my $raw     = $config->{raw}
		or (info "raw output not configured."), return;

	chdir $distdir
		or fault __x"cannot chdir to publish raw in {dir}", dir => $distdir;

	my $rawname = "$distvname-raw";
	my $rawfile = "$rawname.tar.gz";

	info "*  building raw package $rawfile";
	unlink $rawfile;

	my %include;
	foreach my $manifest (bsd_glob "MANIFEST*")
	{	foreach (read_lines $manifest)
		{	s/\s{3,}.*$//;
		    next if m/^#/;
		    next unless length;
		    chomp;
		    $include{$_}++;
		}
	}

	my @include = map "$rawname/$_", sort keys %include;
	symlink('.', $rawname) || readlink $rawname eq '.'
		or fault __x"cannot create temp symlink {name}", name => $rawname;

	local $" = ' ';
	system "tar czf $rawfile @include"
		and fault __x"cannot produce {file} with tar", file => $rawfile;

	my $dest = rel2abs +($raw->{publish} // '.'), $source;
	-d $dest or mkdir $dest
		or fault __x"cannot create {dir}", dir => $dest;

	info "*  publish raw package to $dest";

	move $rawfile, $dest
		or fault __x"cannot move {from} to {to}", from => $rawfile, to => $dest;
}

#
# Create EXPORT
#

sub create_export($$)
{	my ($doc, $gen) = @_;

	my $name   = $gen->{export};
	my $markup = $gen->{markup}  // 'html';
	my $dest   = $gen->{publish} // '-';
	my $serial = $gen->{serializer} // 'json';

	info "** Export data-set $name.";

	my $filters = $gen->{include_manuals} || [];
	my $manuals;
	if(@$filters)
	{	my %manuals;
		foreach my $filter (@$filters)
		{	my @found = grep /^ \Q$filter\E (?: \:\: | $) /ix, map $_->name, $doc->manuals;
			@found or warning __x"No manuals match filter '{filter}'.", filter => $filter;
			$manuals{$_}++ for @found;
		}
		$manuals = [ sort keys %manuals ];
	}

	info "*  creating export with markup $markup." ;

	require OODoc::Export;
	my $exporter = OODoc::Export->new(serializer => $serial, markup => $markup);

	my $tail = oodist_meta $makefile;
	my (undef, $podtail) = create_heads_and_tails $makefile, $tail;
	$tail->{license_year_range} = delete $tail->{year};  # naming improvement

	my $tree = $doc->export(
		exporter => $exporter,
		manuals  => $manuals,
		meta     => $tail,      # only flat key-value, where value is a string
	);

	-d $dest || mkdir $dest
		or fault __x"cannot create export directory {dir}", dir => $dest;

	my $exportfn = catfile $dest, "$distvname-$name.$serial";

	info "** Publish export into $exportfn." ;
	$exporter->write($exportfn, $tree, pretty_print => 1);

	1;
}

# read_makefile($makefile)
# Collect values of variable defined in the specified MAKEFILE, which was
# produced by "perl Makefile.PL"

sub read_makefile($)
{	my $makefile = shift;

	open MAKEFILE, '<', $makefile
	   or fault __x"cannot open produced Makefile: {file}", file => $makefile;

	my %makefile;
	while( <MAKEFILE> )
	{	$_ .= <MAKEFILE> while !eof MAKEFILE && s/\\$//; # continuations
		s/\n\t*/ /g;

		$makefile{$1} = $2 if m/^([A-Z_][A-Z\d_]+)\s*\=\s*(.*?)\s*$/;

		if(m/^#\s+([A-Z_][A-Z\d_]+)\s*\=>\s*(.*?)\s*$/)
		{	# important information which ended-up in comments ;(
		    my ($key, $v) = ($1, $2);
		    $v =~ s/q\[([^\]]*)\]/$1/g;  # remove q[]
		    $makefile{$key} = $v;
		}
	}

	close MAKEFILE;
	\%makefile;
}

# read_meta($json_file)
# Read a META.json or MYMETA.json file into a Perl structure.

sub read_meta($)
{	my $fn = shift;
	JSON->new->utf8(1)->decode(read_binary $fn);
}

###
### convert2version3 $makefile
#   OODoc versions before 3.0 used fields in the Makefile.PL to configure
#   the documentation generation process.  But it got too complex, with
#   growing needs.  Help people convert (help myself to convert 70+ Perl
#   distributions ;-)

sub convert2version3()
{
	print <<__EXPLAIN
*** Your configuration is based on an old OODoc version: you need to convert
*** to a (more convenient) new structure.  This only impacts the configuration:
*** no need to change your documentation.

  ===> 1. Add the output of this to the top of your Makefile.PL:

      $0 --config3
      (hint:  vi Makefile.PL   :r! oodist --config3)

  ===> 2. Merge the following into your "WriteMakefile" call in Makefile.PL

      $0 --merge3
      (hint:  vi Makefile.PL   :r! oodist --merge3)

  ===> 3. Remove the "PREAMBLE" with OODoc values from the Makefile.PL

  ===> 4. Be warned that some command-line options to 'oodist' have changed

*** Merge the above with your Makefile.PL.  Be smart with it.  A documented
*** example can be found in
***       https://github.com/markov2/perl5-OODoc/blob/master/Makefile.PL
__EXPLAIN
}

sub config3()
{
	my $p = sub { my $x = $_[0]; !defined $x ? \"undef" : $x =~ m/^\["']/ ? \$x : \qq{"$x"} };

	my $dist    = $makefile->{DISTDIR};
	my $publish = dirname $dist;

	my $html_output  = $makefile->{HTML_OUTPUT}  // '';
	my $html_docroot = $makefile->{HTML_DOCROOT} // '/';
	my $webpages;
	if($html_output) {
		$webpages = $html_output =~ s/\Q$html_docroot\E$//r;
	}

	print <<__HEAD;
This is an attempt to automatically convert you configuration parameters.

# Use command 'oodist' to produce the documentation before the software release.
my \$webpages = ${ $p->($webpages) };
my \$publish  = ${ $p->($publish =~ s!^\Q$webpages\E!\$webpages!r) };
my \$git      = 'https://github.com/XXX';
my \$homepage = ${ $p->($makefile->{WEBSITE} // 'https://XXX') };

my \%oodoc = (
	first_year => ${ $p->($makefile->{FIRST_YEAR}) },
	email    => ${ $p->($makefile->{EMAIL}) },
__HEAD

	my @include = map "\t\t'$_',\n", sort split /[\: ]+/, $makefile->{EXTENDS};
	print @include ? <<__INCLUDE : '';

	include  => [\n@include],
__INCLUDE

	my @links   = map "\t\t'$_',\n", sort split /[\: ]+/, $makefile->{SKIP_LINKS} // '';
	my $pmhead  = $makefile->{PMHEAD} // (-f 'PMHEAD.txt'  ? 'PMHEAD.txt'  : undef);

	print <<__PARSER;

	parser   => {
		syntax        => 'markov',
		skip_links    => [@links],
		pmhead        => ${ $p->($pmhead) },
	},
__PARSER

	print <<__RELEASE;

	tests    => {
	},

	release  => {
		publish  => "\$publish/${ \basename $dist }",
	},
__RELEASE

	if(my $r = $makefile->{RAWDIR}) { print <<__RAW }

	raw      => {
		publish  => "\$publish/${ \basename $r }",
	},
__RAW

	my @generate;
	my $podtail = $makefile->{PODTAIL} // (-f 'PODTAIL.txt' ? 'PODTAIL.txt' : undef);

	push @generate, <<__POD;
	  {	format         => 'pod3',
		podtail        => ${ $p->($podtail) },
	  },
__POD

	if($html_output)
	{
		push @generate, <<__HTML;
	  {	format         => 'html',
		webpages       => "\$webpages${ $html_docroot eq '/' ? \'' : \$html_docroot },
		publish        => "\$publish/${ \basename $makefile->{HTML_PACKAGE}}",
		docroot        => ${ $p->($html_docroot) },
		templates      => ${ $p->($makefile->{HTML_TEMPLATES}  // 'html') },
		stylesheet     => ${ $p->($makefile->{HTML_STYLESHEET} // '/oodoc.css') },
	  },
__HTML
	}

	print <<__TAIL;

	generate => [\n@generate\t],
);

__TAIL
}

sub merge3()
{
	print <<__MERGE

WriteMakefile
	...
	META_MERGE => {
		'meta-spec' => { version => 2 },
		resources   => {
			repository => {
				type => 'git',
				url  => "\$git.git",
				web  => \$git,
			},
			homepage => \$homepage,
			license  => [ 'https://dev.perl.org/licenses/' ],
		},
		prereqs => {
			develop => {
				requires => {
					'OODoc' => '3.00',
				}
			},
			test => {
				requires => {
					'Test::More' => 0.47,
				}
			},
		},
		x_oodoc => \\\%oodoc,
	};
__MERGE
}

__END__

=head1 NAME

oodist - create perl distributions with OODoc

=head1 SYNOPSIS

 cd $yourmodule
 oodist [OPTIONS]
   OPTION:                 DEFAULT:
   --all                     produce everything except '--no-'
   --pod   or --no-pod       produce pod
   --dist  or --no-dist      package release
   --html  or --no-html      produce html
   --raw   or --no-raw       produce package with raw files
   --tests or --no-tests     run tests
   --export $name            produce a JSON dump of the parsed docs

  OPTIONS general:
   --readme        <file>    constructured
   --workdir  | -w <dir>     /tmp/<DISTVNAME>
   --verbose  | -v           true when specified

  OPTIONS to help convert OODoc2 to OODoc3 style configuration
   --config3                 settings rewrite
   --merge3                  merge meta block

=head1 DESCRIPTION

This script produces documentation from Perl sources, using the OODoc
module.  It can produce better POD, HTML via templates, and exports
from parsed manuals.  As source, it can use real POD or Markov pod
with Object Orientation support extensions.  You may also write your
own documentation parsers, formatters, and exporters.

=section Configuring

Since version 3.0, OODoc requires the configuration to end-up in
the C<MYMETA.json> file, usually via C<META_MERGE> in the C<Makefile.PL>.
You can best have a look at the C<Makefile.PL> of the C<OODoc> package
for an example...

When you have used OODoc before 3.0, then a nice suggestion is produced
on your first call to C<oodist>.

=section Main options

The process is controlled by four main options.  All options are by
default C<on>.

=over 4

=item --all
Create all products, except when expliticly disable with C<--no->.
This is the default, unless any product is enabled explicitly.

=item --pod or --no-pod or --nopod
Produce pod files in the working directory and in the distribution.

=item --dist or --no-dist
Create a distribution, containing all files from the MANIFEST plus
produced files.
Even with C<nodist>, you will end-up with these archives in the
working directory (see C<--workdir>).

=item --html or --no-html
Create html manual pages.  The C<--html-templates> options must
point to an existing directory (defaults to the C<html/> sub-directory).

=item --raw  or --no-raw
Create a package which contains the files which are needed to produce
the distribution: the pm files still including the oodoc markup.

=item --exports or --no-exports

=item --export C<name>
Create a documentation tree (kind of AST) in a certain serialization
type.  At the moment, only C<json> serialization is supported.  You
may multiple export definitions.

=back

=section General options

The other OPTIONS in detail

=over 4

=item --readme <filename>
Copy the specified README file into the distribution, if there is no
README yet.  The name will be added to the MANIFEST.  If the option
is not specified, a simple file will be created.  If this option is
specified, but the filename is empty, then the README will not be
produced.

=item --verbose  | --v
Shows what happens during the process.

=item --workdir  | -w <dir>
The processing will take place in a seperate directory: the stripped pm's
and produced pod files will end-up there.

If not provided, that directory will be named after the project, and
located in C<$ENV{TMPDIR}>, which defaults to C</tmp>.  For instance
C</tmp/OODoc/>

=back
