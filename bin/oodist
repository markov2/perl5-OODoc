#!/usr/bin/env perl

use warnings;
use strict;

use Log::Report   'oodoc';

use Cwd               qw/getcwd realpath/;
use File::Copy        qw/move copy/;
use File::Glob        qw/bsd_glob/;
use File::Slurper     qw/read_text read_binary read_lines/;
use File::Spec        qw/catfile rel2abs/;
use File::Basename    qw/basename dirname/;
use Getopt::Long      qw/GetOptions :config gnu_getopt/;
use HTML::Entities    qw/encode_entities/;
use JSON              ();
use List::Util        qw/first/;
use POSIX             qw/strftime/;

use OODoc             ();

###
### Some constants
###

my $tmpdir      = $ENV{TMPDIR} || '/tmp';

my %licenses =
  ( artistic => <<__ARTISTIC,
This program is free software; you can redistribute it and/or modify it
under the Artistic license.
See F<http://dev.perl.org/licenses/artistic.html>
__ARTISTIC
  , as_perl => <<__PERL,
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See F<http://dev.perl.org/licenses/>
__PERL
  , gpl => <<__GPL
This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
for more details: F<http://www.gnu.org/licenses/gpl.html>
__GPL
);
$licenses{perl}   = $licenses{as_perl};
$licenses{perl_5} = $licenses{as_perl};

sub read_makefile($);
sub read_meta($);
sub parse_additional_dists(@);
sub create_pod($$);
sub create_html($$$$);
sub create_dist($$);
sub publish_dist($$);
sub create_raw_dist($$);
sub publish_raw_dist($$);
sub create_html_dist($$);
sub publish_html_dist($$);
sub create_heads_and_tails($;$);
sub create_readme($$$);
sub create_meta($);
sub create_export($$$);
sub skip_links(@);
sub convert2version3($);

###
### Command-line parsing
###

Getopt::Long::Configure 'bundling';

GetOptions
	'all!'          => \(my $make_all),
	'exports!'      => \(my $make_exports),
	'release!'      => \(my $make_release),
	'export=s'      => \(my $make_export),
	'html!'         => \(my $make_html),
	'pod!'          => \(my $make_pod),
	'raw!'          => \(my $make_raw),
	'readme=s'      => \(my $readmefn),
	'tests|t!'      => \(my $run_tests),
	'verbose|v!'    => \(my $verbose = 0),
	'workdir|w=s'   => \(my $workdir),
	or error __"stopped";

$make_export || ! @ARGV
	or error __x"No command-line arguments expected.";

my $any_requested = $make_release || $make_exports || $make_export || $make_html || $make_pod || $make_raw || $run_tests;
if($make_all || ! $any_requested)
{	# explicit all, but not -no-*
	$_ //= 1 for $make_release, $make_export, $make_html, $make_pod, $make_raw, $run_tests;
}

dispatcher mode => $verbose, 'ALL';

my $ooversion = $OODoc::VERSION || 'devel';

###
### collect some project info
###

system "perl Makefile.PL"
	and fault "cannot run Makefile.PL for basic information";

my $makefile = read_makefile 'Makefile';
if($makefile->{DISTDIR})
{	# Convert pre-version3 into version 3+ data structure
	convert2version3 $makefile;
	exit 1;
}

my $meta      = read_meta 'MYMETA.json';

my $config    = $meta->{x_oodoc} || $meta->{oodoc};
my $author    = $meta->{author} =~ s/\s+\<(.*?)\>//r;
my $email     = $meta->{email}   || $1;

my $project   = $meta->{name};
my $version   = $meta->{version};
my $distvname = "$project-$version";

$workdir ||= "$tmpdir/$project";
-d $workdir || mkdir $workdir
	or fault __x"Cannot create workdir at {dir}", dir => $workdir;

$make_html //= -d $html_templates;

my @extends = split /\:/, $extends;
=cut


info "*** Producing $project version $version";

convert2version3 $makefile;
exit 1; ###

###
### Start OODoc
###

my $doc  = OODoc->new
  ( distribution => $project
  , version      => $version  # version of whole
  );

#
# Reading all the manual pages
# This could be called more than once to combine different sets of
# manual pages in different formats.
#

print "** Extracting data from the distributions";

my $source  = realpath '.';
my %distros = ($project => $meta);
extract_distro 1, $source;

my %included_dirs;

sub extract_distro($$);
sub extract_distro($$)
{	my ($is_root, $dir) = @_;
	return if $included_dirs{$dir};

	my $lib   = "$dir/lib";
	push @INC, $lib unless grep $_ eq $lib, @INC;

	foreach my $include (@{$config->{includes} || []})
	{	my $absdir = realpath (rel2abs $include, $dir);
		extract_distro 0, $absdir;
	}

	# Do not run Makefile.PL because the included distry may be in broken state.

	my $dist_meta = $is_root ? $meta : read_meta "$dir/MYMETA.json";
	my $distname  = $dist_meta->{name};
	my $version   = $dist_meta->{version};

	$distros{$distname}  = $dist_meta;
	$included_dirs{$dir} = $distname;

	info "* processing files of $distname $version";

	my $parser   = OODoc::Parser->new(
		%{$dist_meta->{parser} || { }},
	);

	my ($pmhead, $podtail) = create_heads_and_tails $dist_meta;

	if($is_root)
	{	$doc->processFiles(
			workdir    => $workdir,
			version    => $version,
			parser     => $parser,
			notice     => $pmhead,
		);

		create_readme $doc, $readmefn, $workdir
			if $readmefn && ! -f $readmefn;
	}
	else
	{	$doc->processFiles(
			parser     => $parser,
			select       => qr[^ lib/ .*? \.(pod|pm) $ ]x
		);
	}
}

info "* Preparation phase";

$doc->prepare;

my $license = ($meta->{license} || [ 'perl_5' ])->[0];
my $lictext = $licenses{$license} || '';
if(!$lictext && $license)
{   $lictext = read_text $license
		or fault __"cannot read from licence file {file}", file => $license;
}

my $generate = $meta->{generate} || [];
foreach my $gen (@$generate)
{
	if(my $format = $gen->{format})
	{	if($format =~ /^pod/)
		{	create_pod $doc, $podtail if $make_pod;
		}
		elsif($format =~ /^html/)
		{	create_html $doc, $podtail if $make_html;
		}
		else
		{	error __x"unknown format '{format}' to generate.", format => $format;
		}
	}
	elsif(my $export = $gen->{export})
	{	if($make_exports)
		{	...
			create_export $doc, $make_export, \@ARGV
		}
	}
	else
	{	error __x"unknown generation type in configuration.";
	}
}

# Produce release

chdir $workdir
	or fault __x"cannot go to my {dir}", dir => $workdir;

#create_meta $doc;

if($make_release) {	create_release $meta, $makefile }
else { info "* release not published" }
else            { publish_dist $distdir, $temp_distfn }

# RAW package

chdir $here
	or fault __x"cannot go back to {dir}", dir => $here;

my $temp_rawfn = create_raw_dist $rawdir, $makefile;
publish_raw_dist $rawdir, $temp_rawfn;

# HTML package

if($make_html && $html_package)
{   chdir $html_output
		or fault __x"cannot go to produced html in {dir}", dir => $html_output;

	my $temp_htmlfn = create_html_dist $html_package, $makefile;
	publish_html_dist $html_package, $temp_htmlfn;
}
else
{   info "* no html package published";
}

info "* Ready";
exit 0;

#
# Create pods
#

sub create_pod($$)
{   my ($doc, $podtail) = @_;

	info "* Creating POD files with $format_pod";

	$doc->formatter($format_pod, workdir => $workdir)
		->createPages(
		    select  => sub { my $manual = shift; $manual->distribution eq $project },
		    append  => $podtail,
		  );
}

#
# Create html
#

sub create_html($$$$)
{   my ($doc, $templates, $output, $url) = @_;

	info "* Creating HTML with $format_html, files in $output";

	$doc->formatter($format_html, workdir => $output,
		   format_options   => [ html_root => $url, html_stylesheet => $html_stylesheet ])
		->createPages(
		   manual_format    => [],
		   manual_templates => "$templates/manual",
		   other_templates  => "$templates/other",
		);
}

sub oodist_meta($)
{   my $makefile = shift;

	my $year = strftime "%Y", localtime;
	if($firstyear)
	{   $year = $firstyear =~ m/$year$/ ? $firstyear
		      : $firstyear =~ m/\D$/    ? $firstyear.$year
		      : "$firstyear-$year";
	}

	 +{ today     => (strftime "%B %d, %Y", localtime)
	  , year      => $year     # license year range, backwards compatible name
	  , web       => $website ? " Website: F<$website>" : ''
	  , ooversion => $ooversion
	  };
}

sub project_meta()
{
	my $log  = first { m/^(?:change|contrib)/i } bsd_glob '*';

	 +{ project   => $project
	  , author    => $author ? " by $author" : ''
	  , version   => $version
	  , lictext   => $lictext
	  , changelog => $log
	  };
}

sub create_heads_and_tails($;$)
{   my ($makefile, $oodist_meta) = @_;
	$oodist_meta   ||= oodist_meta $makefile;
	my $project_meta = project_meta;

	$project_meta->{contrib} = $project_meta->{changelog} ? <<__CONTRIB =~ s/\n//r : '';
 For other contributors see $project_meta->{changelog}.
__CONTRIB

	$pmhead
	  = defined $pmheadfn  ? read_text $pmheadfn
	  : -f 'PMHEAD.txt'    ? read_text 'PMHEAD.txt'
	  :                      <<'__PM_HEAD';
Copyrights $year$author.$contrib
See the manual pages for details on the licensing terms.
Pod stripped from pm file by OODoc $ooversion.
__PM_HEAD

	$podtail
	  = defined $podtailfn ? read_text $podtailfn
	  : -f 'PODTAIL.txt'   ? read_text 'PODTAIL.txt'
	  :                      <<'__POD_TAIL';
=head1 SEE ALSO

This module is part of $project distribution version $version,
built on $today.$web

=head1 LICENSE

Copyrights $year$author.$contrib
$lictext
__POD_TAIL

	foreach ($pmhead, $podtail)
	{   s/(?: \$(\w+) | \$\{(\w+)\} )/
		    my $key = $+;
		    my $t   = $oodist_meta->{$key} || $project_meta->{$key};
		    defined $t or error __x"unknown head or tail field '{name}' used", name => $key;
		    $t
		 /gxe
	}

	($pmhead, $podtail);
}

sub create_readme($$$)
{   my ($doc, $readmefn, $workdir) = @_;
	my @toplevel = bsd_glob "$workdir/*";

	my $readme   = first { /\breadme$/i } @toplevel;
	return 1 if $readme;

	info "* adding README";

	my $manifest = first { /\bmanifest$/i } @toplevel;
	open MANIFEST, '>>', $manifest
		or fault __x"cannot append to {file}", file => $manifest;
	print MANIFEST "README\n";
	close MANIFEST;

	$readme      = catfile $workdir, 'README';

	if($readmefn)
	{   # user provided README
		info "* copying $readmefn as README\n";

		copy $readmefn, $readme
			or fault __x"cannot copy {from} to {to}", from => $readmefn, to => $readme;

		return 1;
	}

	#
	# Produce a README text
	#

	open README, '>:encoding(utf8)', $readme
		or fault __x"cannot write to {file}", file => $readme;

	my $date = localtime;

	print README <<__README;
=== README for $project version $version
=   Generated on $date by OODoc $ooversion

There are various ways to install this module:

 (1) if you have a command-line, you can do:
	   perl -MCPAN -e 'install <any package from this distribution>'

 (2) if you use Windows, have a look at http://ppm.activestate.com/

 (3) if you have downloaded this module manually (as root/administrator)
	   gzip -d $project-$version.tar.gz
	   tar -xf $project-$version.tar
	   cd $project-$version
	   perl Makefile.PL
	   make          # optional
	   make test     # optional
	   make install

For usage, see the included manual-pages or
	http://search.cpan.org/dist/$project-$version/

Please report problems to
	http://rt.cpan.org/Dist/Display.html?Queue=$project

__README

	close README;
	1;
}

# Since ExtUtils::MakeMaker, the META files only get updated when
# they already exist.
sub create_meta($)
{   my ($doc) = @_;
	my $manifest = first { /\bmanifest$/i } bsd_glob "*";
	$manifest or panic "No manifest";

	foreach my $fn ('META.yml', 'META.json')
	{   next if -f $fn;
		info "adding $fn";
		open META, '>>', $fn and close META;

		open MANIFEST, '>>', $manifest
			or fault __x"cannot append to {file}", file => $manifest;

		print MANIFEST "$fn\n";
		close MANIFEST;
	}
}

#
# Create a distribution
#

sub prepare_release($)
{   info "** Creating the release for $distvname in $workdir";

	my $release = $meta->{release} or panic;

	system "perl Makefile.PL"
		and fault __x"perl Makefile.PL in {dir} failed", dir => $workdir;

	system "make clean >/dev/null"
		and fault __x"make clean in {dir} failed", dir => $workdir;

	move 'Makefile.old', 'Makefile'
		or fault __x"cannot reinstate Makefile in {dir}", dir => $workdir;

	system "make distdir >/dev/null"
	   and fault __x"make in {dir} failed", dir => $workdir;
}

sub run_tests($)
{	into "** Running tests";

	foreach my $testdir (qw/t tests xt/)
	{   -d $testdir or next;

		info "* Running tests in $testdir";
		system "make test TEST_FILES=$testdir/*.t"
#           and fault __x"make test in {dir} failed", dir => $testdir;
	}
}

sub publish_release()
{	info "** Publish release";
	my $release = $config->{release} or panic;

	my $dest = $release->{publish} // '.';
	-d $dest || mkdir $dest
		or fault __x"cannot create release directory {dir}", dir => $dest;

	my $distfile = "$distvname.tar.gz";

	info "* building distribution in $distfile";
	unlink $distfile;

	system "make dist >/dev/null"
		and fault __x"make dist in {dir} failed", dir => $workdir;

	return if $dest eq $workdir;

	print "Distributed package in $dest/$distfile\n";

	-f $distfile
		or error __x"cannot find produced {file}", file => $distfile;

	-d $dest or mkdir $dest
		or fault __x"cannot create {dir}", dir => $dest;

	move $distfile, $dest
		or fault __x"cannot move {from} to {to}", from => $distfile, to=>$dest;
}

#
# Create RAW
#

sub create_raw()
{   info "** Create package with raw distribution";

	my $raw     = $config->{raw}
		or error __x"raw output not configured";

	my $rawfile = "$distvname-raw.tar.gz";

	info "* building raw package $rawfile";
	
	unlink $rawfile;
	
	my %manifests;
	foreach my $man (bsd_glob "MANIFEST*")
	{   foreach (read_lines $man)
		{	s/\s{3,}.*$//;
		    next if m/^#/;
		    next unless length;
		    chomp;
		    $manifests{$_}++;
		}
	}
	
	my @manifests = map "$rawname/$_", sort keys %manifests;
	symlink('.', $rawname) || readlink $rawname eq '.'
		or fault __x"cannot create temp symlink {name}", name => $rawname;

	local $" = ' ';
	system "tar czf $rawfile @manifests"
		and fault __x"cannot produce {file} with tar", file => $rawfile;

	my $dest = $raw->{publish} or return;

	-d $dest or mkdir $dest
		or fault __x"cannot create {dir}", dir => $dest;

	print "* raw package to $dest/$rawfile\n";

	move $rawfile, $dest
		or fault __x"cannot move {from} to {to}", from => $rawfile, to => $dest;
}

#
# Create HTMLPKG
#

sub create_html_dist($)
{   my $generate = shift;
	my $htmlfile = "$distvname-html.tar.gz";

	info "* Building html package $htmlfile";

	unlink $htmlfile;

	local $" = ' ';
	system "tar czf $htmlfile *"
		and fault __x"cannot produce {file} with tar", file => $htmlfile;

	return if $dest eq $html_output;

	-d $dest || mkdir $dest
		or fault __x"cannot create {dir}", dir => $dest;

	info "* HTML package to $dest/$htmlfile";

	move $htmlfile, $dest
		or fault __x"cannot move {from} to {to}", from => $htmlfile, to=>$dest;
}

#
# Create EXPORT
#

sub create_export($$$)
{   my ($doc, $type, $filters) = @_;

	info "* Collect the published data.";

	my $manuals;
	if(@$filters)
	{   my %manuals;
		foreach my $filter (@$filters)
		{	my @found = grep /^ \Q$filter\E (?: \:\: | $) /ix, map $_->name, $doc->manuals;
		    @found or warning __x"No manuals match filter '{filter}'.", filter => $filter;
		    $manuals{$_}++ for @found;
		}
		$manuals = [ sort keys %manuals ];
	}

	info "* Creating export $type in markup $markup." ;

	require OODoc::Export;
	my $exporter = OODoc::Export->new(serializer => $type, markup => $markup);

	my $tail = oodist_meta $makefile;
	my (undef, $podtail) = create_heads_and_tails $makefile, $tail;
	$tail->{license_year_range} = delete $tail->{year};  # naming improvement

	my $publish = $doc->publish
	  ( exporter => $exporter
	  , manuals  => $manuals
	  , meta     => $tail      # only flat key-value, where value is a string
	  , podtail  => $podtail   # fragment of POD
	  );

	info "* Export into $output." ;

	$exporter->write($output, $publish, pretty_print => 1);

	1;
}

# read_makefile($makefile)
# Collect values of variable defined in the specified MAKEFILE, which was
# produced by "perl Makefile.PL"

sub read_makefile($)
{   my $makefile = shift;

	open MAKEFILE, '<', $makefile
	   or fault __x"cannot open produced Makefile: {file}", file => $makefile;

	my %makefile;
	while( <MAKEFILE> )
	{   $_ .= <MAKEFILE> while !eof MAKEFILE && s/\\$//; # continuations
		s/\n\t*/ /g;

		$makefile{$1} = $2 if m/^([A-Z_][A-Z\d_]+)\s*\=\s*(.*?)\s*$/;

		if(m/^#\s+([A-Z_][A-Z\d_]+)\s*\=>\s*(.*?)\s*$/)
		{	# important information which ended-up in comments ;(
		    my ($key, $v) = ($1, $2);
		    $v =~ s/q\[([^\]]*)\]/$1/g;  # remove q[]
		    $makefile{$key} = $v;
		}
	}

	close MAKEFILE;
	\%makefile;
}

# read_meta($json_file)
# Read a META.json or MYMETA.json file into a Perl structure.

sub read_meta($)
{	my $fn = shift;
	JSON->new->utf8(1)->decode(read_binary $fn);
}

###
### conver2version3 $makefile
#   OODoc versions before 3.0 used fields in the Makefile.PL to configure
#   the documentation generation process.  But it got too complex, with
#   growing needs.  Help people convert (help myself to convert 70+ Perl
#   distributions ;-)

sub convert2version3($)
{	my $makefile = shift;
	my $p = sub { my $x = $_[0]; !defined $x ? \"undef" : $x =~ m/^\["']/ ? \$x : \qq{"$x"} };

	my $dist    = $makefile->{DISTDIR};
	my $publish = dirname $dist;

	my $html_output  = $makefile->{HTML_OUTPUT}  // '';
	my $html_docroot = $makefile->{HTML_DOCROOT} // '/';
	my $webpages;
	if($html_output) {
		$webpages = $html_output =~ s/\Q$html_docroot\E$//r;
	}

	print <<__HEAD;
This is an attempt to automatically convert you configuration parameters.

  ===> 1. Add this to the top of your Makefile.PL:

# Use command 'oodist' to produce the documentation before the software release.
my \$webpages = ${ $p->($webpages) };
my \$publish  = ${ $p->($publish =~ s!^\Q$webpages\E!\$webpages!r) };

my \%oodoc = (
	first_year => ${ $p->($makefile->{FIRST_YEAR}) },
	email      => ${ $p->($makefile->{EMAIL}) },
__HEAD

	my @include = map "\t\t'$_',\n", sort split /[\: ]+/, $makefile->{EXTENDS};
	print @include ? <<__INCLUDE : '';

	include  => [\n@include],
__INCLUDE

	print <<__RELEASE;

	release  => {
		workdir  => ${ $p->('/tmp/' . ($makefile->{NAME} =~ s/::/-/g) },
		publish  => "\$publish/${ \basename $dist }",
	},
__RELEASE

	if(my $r = $makefile->{RAWDIR}) { print <<__RAW }

	raw      => {
		publish  => "\$publish/${ \basename $r }",
	},
__RAW

	my @links   = map "\t\t'$_',\n", sort split /[\: ]+/, $makefile->{SKIP_LINKS} // '';
	my $pmhead  = $makefile->{PMHEAD}  // -f 'PMHEAD.txt'  ? 'PMHEAD.txt'  : undef;
	my $podtail = $makefile->{PODTAIL} // -f 'PODTAIL.txt' ? 'PODTAIL.txt' : undef;

	print <<__PARSER;

	parser   => {
		syntax        => 'markov',
		skip_links    => [@links],
		pmhead        => ${ $p->($pmhead) },
		podtail       => ${ $p->($podtail) },
	},
__PARSER

	my @generate;

	push @generate, <<__POD;
	  {	format         => 'pod3',
	  },
__POD

	if($html_output)
	{
		push @generate, <<__HTML;
	  {	format         => 'html',
		webpages       => "\$webpages${ $html_docroot eq '/' ? \'' : \$html_docroot },
		publish        => "\$publish/${ \basename $makefile->{HTML_PACKAGE}}",
		docroot        => ${ $p->($html_docroot) },
		templates      => ${ $p->($makefile->{HTML_TEMPLATES}  // 'html') },
		stylesheet     => ${ $p->($makefile->{HTML_STYLESHEET} // '/oodoc.css') },
	  },
__HTML
	}

	print <<__TAIL;

	generate => [\n@generate\t],
);

__TAIL

	print <<__MERGE
  ===> 2. Merge the following into your "WriteMakefile" call in Makefile.PL

my \$git      = 'https://github.com/XXX';
my \$homepage = ${ $p->($makefile->{WEBSITE} // 'https://XXX') };

WriteMakefile
	...
	META_MERGE => {
		'meta-spec' => { version => 2 },
		resources   => {
			repository => {
				type => 'git',
				url  => "\$git.git",
				web  => \$git,
			},
			homepage => \$homepage,
			license  => [ 'https://dev.perl.org/licenses/' ],
		},
		prereqs => {
			develop => {
				requires => {
					'OODoc' => '3.00',
				}
			},
			test => {
				requires => {
					'Test::More' => 0.47,
				}
			},
		},
		x_oodoc => \\\%oodoc,
	};
__MERGE

  ===> 3. Remove the "PREAMBLE" with OODoc values from the Makefile.PL

  ===> 4. Be warned that some command-line options to 'oodist' has changed

	print <<__EXPLAIN;

*** Your configuration is based on an old OODoc version: you need to convert
*** to a (more convenient) new structure.  This only impacts the configuration:
*** no need to change your documentation.

*** Merge the above with your Makefile.PL.  Be smart with it.  A documented
*** example can be found in
***       https://github.com/markov2/perl5-OODoc/blob/master/Makefile.PL
__EXPLAIN

}

__END__

=head1 NAME

oodist - create perl distributions with OODoc

=head1 SYNOPSIS

 cd $yourmodule
 oodist [OPTIONS]
   OPTION:                 DEFAULT:
   --all                     produce everything except '--no-'
   --pod   or --no-pod       produce pod
   --dist  or --no-dist      package release
   --html  or --no-html      produce html
   --raw   or --no-raw       produce package with raw files
   --tests or --no-tests     run tests
   --export $name            produce a JSON dump of the parsed docs

  OPTIONS general:
   --readme        <file>    constructured
   --workdir  | -w <dir>     /tmp/<DISTVNAME>
   --verbose  | -v           true when specified

=head1 DESCRIPTION

This script produces documentation from Perl sources, using the OODoc
module.  It can produce better POD, HTML via templates, and exports
from parsed manuals.  As source, it can use real POD or Markov pod
with Object Orientation support extensions.  You may also write your
own documentation parsers, formatters, and exporters.

=section Configuring

Since version 3.0, OODoc requires the configuration to end-up in
the C<MYMETA.json> file, usually via C<META_MERGE> in the C<Makefile.PL>.
You can best have a look at the C<Makefile.PL> of the C<OODoc> package
for an example...

When you have used OODoc before 3.0, then a nice suggestion is produced
on your first call to C<oodist>.

=section Main options

The process is controlled by four main options.  All options are by
default C<on>.

=over 4

=item --all
Create all products, except when expliticly disable with C<--no->.
This is the default, unless any product is enabled explicitly.

=item --pod or --no-pod or --nopod
Produce pod files in the working directory and in the distribution.

=item --dist or --no-dist
Create a distribution, containing all files from the MANIFEST plus
produced files.
Even with C<nodist>, you will end-up with these archives in the
working directory (see C<--workdir>).

=item --html or --no-html
Create html manual pages.  The C<--html-templates> options must
point to an existing directory (defaults to the C<html/> sub-directory).

=item --raw  or --no-raw
Create a package which contains the files which are needed to produce
the distribution: the pm files still including the oodoc markup.

=item --exports or --no-exports

=item --export C<name>
Create a documentation tree (kind of AST) in a certain serialization
type.  At the moment, only C<json> serialization is supported.  You
may multiple export definitions.

=back

=section General options

The other OPTIONS in detail

=over 4

=item --readme <filename>
Copy the specified README file into the distribution, if there is no
README yet.  The name will be added to the MANIFEST.  If the option
is not specified, a simple file will be created.  If this option is
specified, but the filename is empty, then the README will not be
produced.

=item --verbose  | --v
Shows what happens during the process.

=item --workdir  | -w <dir>
The processing will take place in a seperate directory: the stripped pm's
and produced pod files will end-up there.

If not provided, that directory will be named after the project, and
located in C<$ENV{TMPDIR}>, which defaults to C</tmp>.  For instance
C</tmp/OODoc/>

=back
